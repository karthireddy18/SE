Basic Components of a Docker Compose YAML File
1.	Version: Specifies which version of the Docker Compose file format you're using. Each version comes with its own set of features.
version: '3.8'

2.	Services: This section defines all the containers you want to run for your application. Each service represents a container (like a web server or database).
Each service includes:
o	Image: The Docker image to use.
o	Ports: Ports to map between the container and your host machine.
o	Environment: Environment variables required by the service.
o	Dependencies: Which other services a container depends on.
Example:
	
services:
  web:
    image: nginx
    ports:
      - "8060:80"
  db:
    image: tomee
    ports:
      - "8050:8080"

3.	Networks: Define networks to allow different services to communicate with each other. Docker Compose automatically creates a default network if not specified.

4.	Volumes: Used for persistent storage, allowing data to persist even after the container stops or is removed.

Example Docker Compose File (Simple)
Here’s a basic example of a Docker Compose file that runs WordPress and MySQL together:
version: '3.8'  # Docker Compose file format version

services:
  wordpress:  # WordPress service
    image: wordpress:latest
    ports:
      - "8080:80"  # Map port 80 of the container to port 8080 of the host
    environment:
      WORDPRESS_DB_HOST: db:3306  # Database host
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db  # Ensures the db service starts first

  db:  # MySQL service
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

How to Run It
To run a multi-container setup like the one above:
1.	Save the file as docker-compose.yml.
                Or
docker-compose.yaml
2.	To Start the compose

docker-compose up –d

3.	To stop the containers 
       docker-compose down
4.	To scale the container

docker-compose up --scale <service name>=2 -d

1.Define and run multiple interdependent services

Task:
I.	Create a new folder compose-lab
Inside it, create a file docker-compose.yml with the following content:

version: "3.9"
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db

II. Run the setup:

docker compose up -d

III. Open your browser and visit: http://localhost:8080.

IV. Expected Output:

Nginx welcome page is displayed.
db container runs in the background.

2.Write and interpret docker-compose.yml files
Task:
I.	Modify docker-compose.yml to add a Redis cache:

  redis:
    image: redis:alpine

II. Add a depends_on so web waits for Redis:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
    depends_on:
      - redis

III. Restart the setup:
docker compose up -d
docker compose ps

IV. Expected Output:

Three services (web, db, redis) are listed as running.

3.Deploy across different machines
Task:
I.	Zip your compose-lab folder.

Transfer it to another machine with Docker Compose installed.

II. Run:
docker compose up -d

Check that Nginx and Postgres work there as well.

III. Expected Output:
The same services run on the new machine without changes.

4.Networking and persistent storage
Task:
I.	Update your docker-compose.yml to add a custom network and volume:

networks:
  app-net:

volumes:
  db-data:

services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
    networks:
      - app-net
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - app-net

II. Run:
docker compose up -d
III. Insert some data into Postgres (optional with psql).
docker exec -it {name of the database started} psql -U demo -d demo_db
IV. Remove containers:
docker compose down
V. Start again:
docker compose up -d
VI. Expected Output:
Database data persists across restarts.
Services communicate via the app-net network using service names.

5.Faster iteration during development
Task: 
I.	Create a simple Flask app in app.py:

from flask import Flask
app = Flask(__name__)
@app.route("/")
def home():
    return "Hello from Flask + Docker!"
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

II. Add a Dockerfile in the same folder:

FROM python:3.10-slim
WORKDIR /app
COPY app.py /app/
RUN pip install flask
CMD ["python", "app.py"]

III. Update docker-compose.yml:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
IV. Run:
docker compose up --build
Visit http://localhost:5000.
Change the return text in app.py (e.g., "Hello Docker Compose!").
V. Rebuild:
docker compose up --build
VI. Expected Output:
New message appears instantly after rebuild.
